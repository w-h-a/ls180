Here's my step-by-step walk through for assignment 12.

PART I
1. After making a database for assignment 12, I imported the required file.
2. I checked the relation list and their implemented schemas. After some thought, I figured that we could think of categories like concepts that are realized by concrete objects like books. So, just as I realize the concept of _student-hood_ (since (a) I exemplify _being a student_ and (b) the concept of _student-hood_ encodes _being a student_), _A Tale of Two Cities_ realizes both the category of _fiction_ and the category of _classics_ (since (a) _A Tale of Two Cities_ exemplifies _being a work of classic fiction_ and (b) the category of _fiction_ encodes _being a work of fiction_ and the category of _classics_ encodes _being a classic work_.) This sounds good, but to make sure I also tested some of the others. For example, if the Einstein biography is (among other things) a work of physics, then I think it also makes sense to say that _Einstein: His Life and Universe_ realizes the category of _physics_ because (a) the book exemplifies _being a work of physics_ (albeit not a primary source) and (b) the category of _physics_ encodes _being a work of physics_.
3. Given the above, I decided to construct a more complete conceptual schema before continuing.
  - The entity classes are:
    - _book_ (`alter table books rename to book;`)
    - _category_ (`alter table categories rename to category;`)
  - The relationship classes are:
    - _realizes_
      - `alter table books_categories rename to realizes;`
      - `alter table realizes add column id int generated by default as identity primary key;`
      - `alter table realizes rename constraint "books_categories_book_id_fkey" to "realizes_book_id_fkey";`
      - `alter table realizes rename constraint "books_categories_category_id_fkey" to "realizes_category_id_fkey";`
  - Now each item class has a relation schema (and more).
  - The cardinality constraints are:
    - `card(realizes, book) = MANY`
    - `card(realizes, category) = MANY` (so _realizes_ is a many-to-one relationship).
  - Now I have a complete conceptual schema of this relational database, and I have reorganized the relational database to better fit this conceptual schema.
4. Now we can return a virtual relation between author and categories by submitting:
  - To solve I wrote: `select author, string_agg(category.name, ', ') as categories from book join realizes on realizes.book_id = book.id join category on category.id = realizes.category_id group by author;`
  - Compare Launch's: `SELECT books.id, books.author, string_agg(categories.name, ', ') AS categories FROM books INNER JOIN books_categories ON books.id = books_categories.book_id INNER JOIN categories ON books_categories.category_id = categories.id GROUP BY books.id ORDER BY books.id;`

PART II
To add to our relations, let's insert some more data in accordance with Launch's instructions:
  - To solve I wrote:
    - `alter table book alter column title type varchar(100);`
    - `insert into book (title, author) values ('Vikram Vij Vij''s: Elegant and Inspired Indian Cuisine Cookbook', 'Meeru Dhalwala');`
    - `insert into book (title, author) values ('Jane Eyre', 'Charlotte Brontë');`
    - `insert into book (title, author) values ('Sally Ride: America''s First Woman in Space', 'Lynn Sherr');`
    - `insert into category (name) values ('Cookbook'), ('South Asia'), ('Space Exploration');`
    - `insert into realizes (book_id, category_id) values (4, 7), (4, 1), (4, 8), (5, 2), (5, 4), (6, 1), (6, 5), (6, 9);`
  - Compare Launch's:
    - `ALTER TABLE books ALTER COLUMN title TYPE text;`
    - `INSERT INTO books (title, author) VALUES ('Sally Ride: America''s First Woman in Space', 'Lynn Sherr');`
    - `INSERT INTO books_categories VALUES (4, 1);`
    - `INSERT INTO books_categories VALUES (4, 5);`
    - `INSERT INTO categories (name) VALUES ('Space Exploration');`
    - `INSERT INTO books_categories VALUES (4, 7);`
    - `INSERT INTO books (title, author) VALUES ('Jane Eyre', 'Charlotte Brontë');`
    - `INSERT INTO books_categories VALUES (5, 2);`
    - `INSERT INTO books_categories VALUES (5, 4);`
    - `INSERT INTO books (title, author) VALUES ('Vij''s: Elegant and Inspired Indian Cuisine', 'Meeru Dhalwala and Vikram Vij');`
    - `INSERT INTO categories (name) VALUES ('Cookbook');`
    - `INSERT INTO categories (name) VALUES ('South Asia');``
    - `INSERT INTO books_categories VALUES (6, 1);`
    - `INSERT INTO books_categories VALUES (6, 8);`
    - `INSERT INTO books_categories VALUES (6, 9);`

PART III
From Launch: "Write a SQL statement to add a uniqueness constraint on the combination of columns book_id and category_id of the books_categories table. This constraint should be a table constraint; so, it should check for uniqueness on the combination of book_id and category_id across all rows of the books_categories table."
  - My solution is the same as Launch's: `alter table realizes add unique (book_id, category_id);`

PART IV
To return a relation between category name, count of books under the category, and a list of book titles, we may submit:
  - To solve I wrote: `select name, count(book_id), string_agg(title, ', ') as titles from book join realizes on realizes.book_id = book.id join category on category.id = realizes.category_id group by name order by name;`
  - Compare Launch's: `SELECT categories.name, count(books.id) as book_count, string_agg(books.title, ', ') AS book_titles FROM books INNER JOIN books_categories ON books.id = books_categories.book_id INNER JOIN categories ON books_categories.category_id = categories.id GROUP BY categories.name ORDER BY categories.name;`
