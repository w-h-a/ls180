Here is my step-by-step walk through for assignment 5 of lesson 4.

PART I

The entity classes are _bidder_ and _item_. The relationship class is _bids_. The cardinality constraints are many-to-many. Here are our implemented relation schemas:

```sql
create table bidder(
  bidder_id int generated by default as identity primary key,
  bidder_name text not null
);

create table item(
  item_id int generated by default as identity primary key,
  item_name text not null,
  initial_price numeric(6, 2) not null,
  sales_price numeric(6, 2)
);

create table bids(
  bids_id int generated by default as identity primary key,
  bidder_id int not null references bidder(bidder_id) on delete cascade,
  item_id int not null references item(item_id) on delete cascade,
  amount numeric(6, 2) not null
);

create index on bids(bidder_id, item_id);
```

Constructing our relations:

```sql
\copy bidder from 'bidder.csv' with header csv;
\copy item from 'item.csv' with header csv;
\copy bids from 'bids.csv' with header csv;
```

PART II

To return all and only items that have bids:

```sql
select
  item_name as "Items with Bids"
from item
where
  exists(
    select 1
    from bids
    where
      bids.item_id = item.item_id
  );

select
  item_name as "Items with Bids"
from item
where
  item_id in(
    select item_id
    from bids
  );

select
  item_name as "Items with Bids"
from item
where
  item_id = some(
    select item_id
    from bids
  );
```

PART III

To return all and only items without bids:

```sql
select
  item_name as "Items without Bids"
from item
where
  item_id not in(
    select item_id
    from bids
  );

select
  item_name as "Items without Bids"
from item
where
  item_id != all(
    select item_id
    from bids
  );

select
  item_name as "Items without Bids"
from item
where
  not exists(
    select 1
    from bids
    where
      bids.item_id = item.item_id
  );
```

PART IV

To return all _and only_ those who have bids (subqueries):

```sql
select
  bidder_name
from bidder
where
  exists(
    select 1
    from bids
    where
      bids.bidder_id = bidder.bidder_id
  );

select
  bidder_name
from bidder
where
  bidder_id = some(
    select bidder_id
    from bids
  );

select
  bidder_name
from bidder
where
  bidder_id in(
    select bidder_id
    from bids
  );
```

To return all _and only_ those who have bids (joins):

```sql
select
  bidder_name
from bidder
inner join bids using(bidder_id)
group by bidder_id
order by bidder_id;
```

PART V

I had the same intuition as Giuseppe:

```sql
with bid_count as(
  select count(bids_id)
  from bids
  group by bidder_id
)
select
  max(count)
from bid_count;
```

PART VI

To return a virtual relation between `item_name` and the count of bids on the item:

```sql
select
  item_name,
  (
    select count(item_id)
    from bids
    where
      item_id = item.item_id
  )
from item;

select
  item_name,
  count(bids.item_id)
from item
left join bids using(item_id)
group by item_id
order by item_id;
```

PART VII

```sql
select
  item_id
from item
where
  not(item_name != 'Painting' or
  initial_price != 100.00 or
  sales_price != 250.00);

select
  item_id
from item
where
  ('Painting', 100.00, 250.00) = (item_name, initial_price, sales_price);
```

PART VIII



PART IX
