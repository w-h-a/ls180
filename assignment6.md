Here's my step-by-step walk through for assignment 6.

PART I
1. I installed the `theater_full.sql` database.
2. I checked the relation list using `\dt`.
3. I needed to create my own conceptual schema to fully understand what's going on here.
  - The entity classes are:
    - _customer_ (so I do a relation name change: `alter table customers rename to customer;`).
    - _event_ (so I do a name change: `alter table events rename to event;`).
    - _seat_ (so I do a name change: `alter table seats rename to seat;`).
    - _section_ (so I do a name change: `alter table sections rename to section;`).
    - _ticket_ (so I do a name change: `alter table tickets rename to ticket;`).
  - The relationship classes are not made explicit in the implemented schema; so, I did some digging in the database.
   - I create a section-_contains_-seat relationship class.
     1. `create table contains(id int generated by default as identity primary key, seat_id int references seat(id), section_id int references section(id));`
     2. `insert into contains (seat_id, section_id) select id, section_id from seat;`
     3. `alter table contains alter column seat_id set not null;`
     4. `alter table contains alter column section_id set not null;`
     5. `alter table seat drop column section_id;`
   - I create a ticket-_claims_-seat relationship class.
     1. `create table claims(id int generated by default as identity primary key, ticket_id int references ticket(id), seat_id int references seat(id));`
     2. `insert into claims (ticket_id, seat_id) select id, seat_id from ticket;`
     3. `alter table claims alter column ticket_id set not null;`
     4. `alter table claims alter column seat_id set not null;`
     5. `alter table ticket drop column seat_id;`
   - I create an event-_sells_-ticket relationship class.
     1. `create table sells(id int generated by default as identity primary key, event_id int references event(id), ticket_id int references ticket(id));`
     2. `insert into sells (event_id, ticket_id) select event_id, id from ticket;`
     3. `alter table sells alter column event_id set not null;`
     4. `alter table sells alter column ticket_id set not null;`
     5. `alter table ticket drop column event_id;`
   - I create a customer-_buys_-ticket relationship class.
     1. `create table buys(id int generated by default as identity primary key, customer_id int references customer(id), ticket_id int references ticket(id));`
     2. `insert into buys (customer_id, ticket_id) select customer_id, id from ticket;`
     3. `alter table buys alter column customer_id set not null;`
     4. `alter table buys alter column ticket_id set not null;`
     5. `alter table ticket drop column customer_id;`
  - Now each item (either entity or relationship) class has a relation schema and corresponding relation in my database.
  - The cardinality constraints are specified as follows:
    - `card(contains, section) = MANY`
    - `card(contains, seat) = ONE` (so _contains_ is a many-to-one relationship class).
    - `card(claims, ticket) = ONE`
    - `card(claims, seat) = MANY` (so _claims_ is a one-to-many relationship class).
    - `card(sells, event) = MANY`
    - `card(sells, ticket) = ONE` (so _sells_ is a many-to-one relationship class).
    - `card(buys, customer) = MANY`
    - `card(buys, ticket) = ONE` (so _buys_ is a many-to-one relationship class).
  - Now I have a complete conceptual schema of this relational database, and I have reorganized the relational database to better fit this conceptual schema.

PART II
To figure out how many tickets have been sold, we may submit any of the following:
  - `select count(id) from sells;`
  - `select count(id) from buys;`
  - `select count(id) from ticket;` (which means there is no unsold ticket)
  - Compare Launch's: `SELECT COUNT(*) FROM tickets;`

PART III
To figure out how many distinct customers purchased tickets, we may submit:
  - `select count(distinct customer_id) from buys;`
  - Compare Launch's: `SELECT COUNT(DISTINCT customer_id) FROM tickets;`

Notes: I don't find it intuitive that the _ticket_ class (or set of tickets) has a `customer_id`; so, I prefer my solution which makes the relationships explicit and queries more natural. However, I suspect some will find my solution strange. There are many ways to skin a cat.

PART IV
To figure out the percentage of purchasing customers, we may submit:
  - To solve I wrote: `select round(count(distinct buys.customer_id) / count(distinct customer.id)::decimal * 100, 2) as percent from customer left outer join buys on buys.customer_id = customer.id;`
  - Compare Launch's: `select round(count(distinct tickets.customer_id) / count(distinct customers.id)::decimal * 100, 2) as percent from customers left outer join tickets on tickets.customer_id = customers.id;`

PART V
To return a relation between event names (as "`names`") and number of sold tickets (as "`popularity`") in order from most popular to least, we may submit:
  - To solve I wrote: `select event.name, count(sells.event_id) as popularity from event join sells on sells.event_id = event.id group by event.name order by popularity desc;`
  - Compare Launch's: `select events.name, count(tickets.id) as popularity from events left outer join tickets on tickets.event_id = events.id group by events.id order by popularity desc;`

Notes: I got rid of the aliases here. It was not specified that \<name, NULL\> relation elements should be included (if any).

PART VI
To return a relation between `id`, `email`, and `count` of events for customers that have purchased tickets to three distinct events, we may submit:
  - To solve I wrote: `select customer.id, customer.email, count(distinct sells.event_id) from customer join buys on buys.customer_id = customer.id join ticket on ticket.id = buys.ticket_id join sells on sells.ticket_id = ticket.id group by customer.id having count(distinct sells.event_id) > 2;`
  - Compare Launch's: `select customers.id, customers.email, count(distinct tickets.event_id) from customers inner join tickets on tickets.customer_id = customers.id group by customers.id having count(distinct tickets.event_id) = 3;`

Notes: Launch's solution is shorter but it is not as semantically intuitive. The third element of each relation element ought to be the `count` of distinct events. In my solution, that the ticket was sold by an event and bought by a customer is made explicit. An event sells tickets to buying customers. Consequently, we must write a bunch of joins. In Launch's solution, we already have to know a lot about the database and domain to infer that the ticket was sold by an event and bought by a customer. All we get from the official solution is that somehow events, tickets, and customers are related. Furthermore, it was not specified that `count` was to be for customers that have purchased tickets to _exactly_ three distinct events. The exact wording at Launch is "for all customers that have purchased tickets to three events." Given this, my solution using "`> 2`" is the more natural interpretation.

PART VII
To return a relation between event name, when the event starts, the seat's section name, the seat's row, and the seat's number for customers with the email address 'gennaro.rath@mcdermott.co', we may submit:
  - To solve I wrote: `select event.name as event, event.starts_at, section.name as section, seat.row, seat.number as seat from event join sells on sells.event_id = event.id join ticket on ticket.id = sells.ticket_id join claims on claims.ticket_id = ticket.id join seat on seat.id = claims.seat_id join contains on contains.seat_id = seat.id join section on section.id = contains.section_id join buys on buys.ticket_id = ticket.id join customer on customer.id = buys.customer_id where customer.email = 'gennaro.rath@mcdermott.co';`
  - Compare Launch's: `select events.name as event, events.starts_at, sections.name as section, seat.row, seats.number as seat from tickets inner join events on tickets.event_id = events.id inner join customers on tickets.customer_id = customers.id inner join seats on tickets.seat_id = seat.id inner join sections on seats.section_id = sections.id where customers.email = 'gennaro.rath@mcdermott.co';`


























f
