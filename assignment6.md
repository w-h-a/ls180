Here's my step-by-step walk through for assignment 6.

PART I
1. I installed the `theater_full.sql` database.
2. I checked the relation list using `\dt`.
3. I needed to create my own conceptual schema to fully understand what's going on here.
  - The entity classes are:
    - _customer_ (so I do a relation name change: `alter table customers rename to customer;`).
    - _event_ (so I do a name change: `alter table events rename to event;`).
    - _seat_ (so I do a name change: `alter table seats rename to seat;`).
    - _section_ (so I do a name change: `alter table sections rename to section;`).
    - _ticket_ (so I do a name change: `alter table tickets rename to ticket;`).
  - The relationship classes are not made explicit in the implemented schema; so, I did some digging in the database.
   - I create a section-_contains_-seat relationship class.
     1. `create table contains(id int generated by default as identity primary key, seat_id int references seat(id), section_id int references section(id));`
     2. `insert into contains (seat_id, section_id) select id, section_id from seat;`
     3. `alter table contains alter column seat_id set not null;`
     4. `alter table contains alter column section_id set not null;`
     5. `alter table seat drop column section_id;`
   - I create a ticket-_claims_-seat relationship class.
     1. `create table claims(id int generated by default as identity primary key, ticket_id int references ticket(id), seat_id int references seat(id));`
     2. `insert into claims (ticket_id, seat_id) select id, seat_id from ticket;`
     3. `alter table claims alter column ticket_id set not null;`
     4. `alter table claims alter column seat_id set not null;`
     5. `alter table ticket drop column seat_id;`
   - I create an event _sells_ ticket relationship class.
     1. `create table sells(id int generated by default as identity primary key, event_id int references event(id), ticket_id int references ticket(id));`
     2. `insert into sells (event_id, ticket_id) select event_id, id from ticket;`
     3. `alter table sells alter column event_id set not null;`
     4. `alter table sells alter column ticket_id set not null;`
     5. `alter table ticket drop column event_id;`
   - I create a customer _buys_ ticket relationship class.
     1. `create table buys(id int generated by default as identity primary key, customer_id int references customer(id), ticket_id int references ticket(id));`
     2. `insert into buys (customer_id, ticket_id) select customer_id, id from ticket;`
     3. `alter table buys alter column customer_id set not null;`
     4. `alter table buys alter column ticket_id set not null;`
     5. `alter table ticket drop column customer_id;`
  - Now each item (either entity or relationship) class has a relation schema and corresponding relation in my database.
  - The cardinality constraints are specified as follows:
    - `card(contains, section) = MANY`
    - `card(contains, seat) = ONE` (so _contains_ is a many-to-one relationship class).
    - `card(claims, ticket) = ONE`
    - `card(claims, seat) = MANY` (so _claims_ is a one-to-many relationship class).
    - `card(sells, event) = MANY`
    - `card(sells, ticket) = ONE` (so _sells_ is a many-to-one relationship class).
    - `card(buys, customer) = MANY`
    - `card(buys, ticket) = ONE` (so _buys_ is a many-to-one relationship class).
  - Now I have a complete conceptual schema of this relational database, and I have reorganized the relational database to better fit this conceptual schema.

PART II
To figure out how many tickets have been sold, we may submit any of the following:
  - `select count(id) from sells;`
  - `select count(id) from buys;`
  - `select count(id) from ticket;` (which means there is no unsold ticket)

PART III
To figure out how many distinct customers purchased tickets

Write a query that determines how many different customers purchased tickets to at least one event.
















f
