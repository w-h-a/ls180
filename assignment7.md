Here's my step-by-step walk through for assignment 7.

PART I
1. After making a database for assignment 7, I imported the required file.
2. I checked the relation list. There is a products relation schema and an orders relation schema, but we're not given any additional information about the corresponding item classes. It is very unclear to me how to proceed if we're not given any intuition about the database or domain.
3. I needed to create a conceptual schema for an essentially empty database. I imagine there are employees that order products.
  - The entity classes are:
    - _employee_ (`create table employee(id int generated by default as identity primary key);`)
    - _product_ (`alter table products rename to product;`)
  - The relationship classes are:
    - _orders_ (`alter table orders add column employee_id int references employee(id);`)
  - Now each item class has a relation schema (that will likely change a bit).
  - The cardinality constraints are specified as follows:
    - `card(orders, employee) = MANY`
    - `card(orders, product) = MANY` (so _orders_ is a many-to-many relationship).
  - Now I have a complete conceptual schema of this relational database, and I have reorganized the relational database to better fit this conceptual schema.

PART II
From Launch: "Update the orders table so that referential integrity will be preserved for the data between orders and products."

To update the orders relation schema to preserve referential integrity between the orders relation and products relation, we may submit:
  - To solve I wrote: `alter table orders add foreign key (product_id) references product(id);`
  - Compare Launch's: `alter table orders add constraint orders_product_id_fkey foreign key (product_id) references products(id);`

PARTS III and IV
To return a relation, we need to create some relations. Here's a start:
  1. `insert into employee (id) values (1);`
  2. `insert into product (name) values ('small bolt'), ('large bolt');`
  3. `insert into orders (employee_id, product_id, quantity) values (1, 1, 10), (1, 1, 25), (1, 2, 15);`

Now, for example, we can return a relation of quantity and product name.
  - To solve I wrote: `select orders.quantity, product.name from product join orders on orders.product_id = product.id;`
  - Compare Launch's: `SELECT quantity, name FROM orders INNER JOIN products ON orders.product_id = products.id;`

PART V
From Launch: "Can you insert a row into orders without a product_id?"

Yes.

PART VI
From Launch: "Write a SQL statement that will prevent NULL values from being stored in orders.product_id."
  - To solve I wrote:
    - `alter table orders alter column product_id set not null;`
    - `alter table orders alter column employee_id set not null;`
  - Compare Launch's:
    - `ALTER TABLE orders ALTER COLUMN product_id SET NOT NULL;`

PART VII
Skipped

PARTS VIII, IX, and X
Next Launch asks us to create a new reviews relation. It is not specified whether the relation corresponds to an entity or a relationship class. Perhaps employees, in addition to ordering products, _review_ products sometimes. Thinking of it like that, a _reviews_ relationship class is natural. We could also make a _review_ entity class so that employees write reviews, which are, in turn of products. But that might only be worth while if multiple employees are involved in writing the same review. Whether we go with a _review_ entity class or a _reviews_ relationship class, I think it is most natural to change the name of the employee relation to be "customer". If we would have been given more information about the domain at the get-go, we wouldn't have run into this problem. But now we have an opportunity to practice with "`alter`":
  1. `alter table employee rename to customer;`
  2. `alter table orders rename column employee_id to customer_id;`
  3. `alter table orders rename constraint "orders_employee_id_fkey" to "orders_customer_id_fkey";`

Okay, now let's keep things simple and add a _reviews_ many-to-many relationship and, in particular, its corresponding relation schema:
  1. `create table reviews(id int generated by default as identity primary key, customer_id int references customer(id), product_id int references product(id), body text not null);`
  2. `alter table reviews alter column customer_id set not null;` (forgot this!)
  3. `alter table reviews alter column product_id set not null;` (forgot this!)

Going beyond schema now:
  1. `insert into customer (id) values (2);`
  2. `insert into orders (customer_id, product_id, quantity) values (2, 1, 40);`
  3. `insert into reviews (customer_id, product_id, body) values (1, 1, 'a wee too small really'), (2, 1, 'rounder than advertised.'), (1, 2, 'a bit too big really');`

Now, for example, we can return new (virtual) relations like:
  1. `select product.name as product, reviews.body as review from product join reviews on reviews.product_id = product.id;`
  2. `select customer.id as user, product.name as product, reviews.body as review from customer join reviews on reviews.customer_id = customer.id join product on product.id = reviews.product_id;`
