Here's my step-by-step walk through for assignment 9 (assignment 13 is included as well).

1. After making a database for assignment 9, I imported the required file.
2. I checked the relation list, and rename the films relation to "film". The film relation corresponds to a set of films, but I like to give the corresponding class has a singular name. So, I like to title the relation accordingly.
3. I checked the schema for the film relation. I suspected that in this assignment we will need to revamp the conceptual and implemented schemas. In particular, I figured we'd probably be giving director its own entity class. I also wanted to make the _directs_ relationship class explicit. I tried to refactor before reading the rest of the assignment. I thought that if I screwed up, it give me extra practice.
4. I needed to make my conceptual schema clear before moving on.
  - The entity classes are:
    - _director_
      1. `create table director(id int generated by default as identity primary key, name text not null unique);`
      2. `insert into director (name) select distinct director from film;`
    - _film_ (`alter table film add column id int generated by default as identity primary key;`)
  - The relationship classes are:
    - _directs_
      1. `create table directs(id int generated by default as identity primary key, director_id int references director(id), film_id int references film(id));`
      2. `insert into directs (director_id, film_id) select director.id, film.id from director join film on film.director = director.name;`
      3. `alter table directs alter column director_id set not null;`
      4. `alter table directs alter column film_id set not null;`
      5. `alter table film drop column director;`
  - Now each item class has a relation schema (and more).
  - Since there are many movies that are co-directed, the cardinality constraints should be:
    - `card(directs, director) = MANY`
    - `card(directs, film) = MANY` (so _directs_ is a many-to-many relationship).
  - Now I have a complete conceptual schema of this relational database, and I have reorganized the relational database to better fit this conceptual schema.
5. I decided to add some of my favorites to practice:
  - `insert into film (title, year, genre, duration) values ('The Mirror', 1975, 'essay film', 108), ('Tokyo Story', 1953, 'drama', 134), ('Rules of the Game', 1939, 'comedy drama', 110), ('M', 1931, 'thriller', 117), ('Fanny och Alexander', 1982, 'drama', 180);`
  - `insert into director (name) values ('Andrei Tarkovsky'), ('Yasujiro Ozu'), ('Jean Renoir'), ('Fritz Lang'), ('Ingmar Bergman');`
  - `insert into directs (director_id, film_id) values (7, 8), (8, 9), (9, 10), (10, 11), (11, 12);`
6. After I had read the assignment, I realized that I had dropped a constraint on accident:
  - `alter table director add constraint permitted_name check (length(name) >= 1 and position(' ' in name) > 0);`
7. I then noticed that I had jumped the gun. Much of what I accomplished above could be used as a solution for much of assignment 13. So let's continue! One thing I noticed right off the bat is that in the Launch material _Let the Right One In_ is assigned the wrong director. Let's fix that!
  - `insert into film (title, year, genre, duration) values ('Let the Right One In', 2008, 'horror, drama', 110);`
  - `insert into directs (director_id, film_id) values (4, 13);`
8. Now we can return a virtual relation between film title and director name that is ordered by film title:
  - To solve I wrote: `select title, name from director join directs on directs.director_id = director.id join film on film.id = directs.film_id order by title;`
  - Compare Launch's: `SELECT films.title, directors.name FROM films INNER JOIN directors_films ON directors_films.film_id = films.id INNER JOIN directors ON directors.id = directors_films.director_id ORDER BY films.title ASC;`
9. Let's add some additional data, in accordance with Launch's instructions:
  - To solve I wrote:
    - `insert into director (name) values ('Joel Coen'), ('Ethan Coen');`
    - `insert into film (title, year, genre, duration) values ('Fargo', 1996, 'crime comedy', 98), ('No Country For Old Men', 2007, 'western thriller', 124);`
    - `insert into directs (director_id, film_id) values (12, 14), (12, 15), (13, 15);`
  - There were no surprises from Launch's solution.
10. To return a relation between director name and count of directed films sorted in descending order by count and then by name, we may submit:
  - To solve I wrote: `select name, count(director_id) from director join directs on directs.director_id = director.id group by name order by count desc, name;`
  - Compare Launch's: `select directors.name as director, count(directors_films.film_id) as films from directors inner join directors_films on directors.id = directors_films.director_id group by directors.id order by films desc, directors.name asc;`

Notes: Thinking in terms of entity and relationship classes definitely makes the join/reference relation much more intuitive, I think. It's immediately clear what the directs relation is, but it is not immediately clear what the directors_films relation is.
